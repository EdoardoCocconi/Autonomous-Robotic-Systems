#pragma config(Sensor, S1, colorSensor, sensorI2CCustom)
#pragma config(Sensor, S2,     leftUltrasonic, sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     righUltrasonic, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     gyro,           sensorEV3_Gyro)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "HitechnicColorSensor.h"

#define MOTORSPEED 5
#define BUFFSIZE 4
#define LOSTTIME 4000


// current state of robot
enum states{OBSERVE, AVOIDING, FINDING, FOLLOWING, COUNT};

struct properties {
	int leftSpeed;
	int rightSpeed;
	bool active;
};

struct properties robotProperties[COUNT];
enum states state = FINDING;

int threshold = 12;
int leftSpeed = 0;
int rightSpeed = 0;

// Current Light Level
int light = 10000;

// Current output of gyro in degrees
int deg = 0;

//Current output of the ultrasonic sensors
int distL = 100;
int distR = 100;

#define WINDOWSIZE 3

int lightWindow[WINDOWSIZE] = {0,25123,987618};

unsigned long windowCounter = 0;

int avg()
{
	int average  = 0;

	for(int x = 0 ;x<WINDOWSIZE;x++)
	{
		average+=lightWindow[x];
	}
	return average/WINDOWSIZE;
}

float stdv()
{
	float stanDeviation  = 0.0;

	for(int x = 0; x<WINDOWSIZE; x++)
	{
		stanDeviation += pow((lightWindow[x] - avg()),2);
	}
	return sqrt(stanDeviation/WINDOWSIZE);
}



task readSensors()
{
	struct data {
		int light;
		int leftUlt;
		int rightUlt;
	};
	struct data myData[BUFFSIZE];
	while(1)
	{
		int avgLight = 0;
		int avgLeftUlt = 0;
		int avgRightUlt = 0;
		for(int x = 0; x<BUFFSIZE;x++)
		{
			HTCS2readRawWhite(colorSensor, true, myData[x].light);
			myData[x].leftUlt = getUSDistance(S2);
			myData[x].rightUlt = getUSDistance(S3);
		}
		for(int y = 0; y<BUFFSIZE; y++)
		{
			avgLight += myData[y].light;
			avgLeftUlt += myData[y].leftUlt;
			avgRightUlt += myData[y].rightUlt;

		}
		light = avgLight / BUFFSIZE;


		lightWindow[windowCounter % WINDOWSIZE] = myData[0].light;
		windowCounter++;

		distL = avgLeftUlt / BUFFSIZE;
		distR = avgRightUlt / BUFFSIZE;
		deg = getGyroDegrees(gyro);

	}
}

task findLine()
{
	while(true)
	{
		robotProperties[FINDING].leftSpeed = MOTORSPEED * 4;
		robotProperties[FINDING].rightSpeed = MOTORSPEED * 2.8;

		// we've found the line
		if(light < 500)
		{
			robotProperties[FINDING].leftSpeed = 0;
			robotProperties[FINDING].rightSpeed = 0;
			robotProperties[FINDING].active = false;
			sleep(150);

		}
		else
		{
			robotProperties[FINDING].active = true;
		}
	}
}

task avoid()
{


#define AVOIDSPEED 4
#define AVOIDDIST 6
#define TURNTIME 3200


	enum avoidStates {
		backup,
		turn,
		goStraight,
		go,
		nothing,
	};

	int state = nothing;

	while(true)
	{

		if(distL < AVOIDDIST || distR < AVOIDDIST)
		{
			robotProperties[AVOIDING].active = true;
			if(state == nothing)
				state = backup;
			clearTimer(T2);
		}
		//writeDebugStreamLine("%d %d", state, time1[T2]);
		switch(state)
		{
		case backup:
			if(time1[T2] < 400)
			{
				robotProperties[AVOIDING].leftSpeed = -AVOIDSPEED;
				robotProperties[AVOIDING].rightSpeed = -AVOIDSPEED;
			}
			else
			{
				state = turn;
				clearTimer(T2);
			}
			break;
		case turn:
			if(time1[T2] < TURNTIME)
			{
				robotProperties[AVOIDING].leftSpeed = AVOIDSPEED;
				robotProperties[AVOIDING].rightSpeed = -AVOIDSPEED;
			}
			else
			{
				clearTimer(T2);
				state = goStraight;
			}
			break;
		case goStraight:
			if(time1[T2] < 800)
			{
				robotProperties[AVOIDING].leftSpeed = AVOIDSPEED;
				robotProperties[AVOIDING].rightSpeed = AVOIDSPEED;
			}
			else
			{
				state = go;
				clearTimer(T2);
			}
			break;
		case go:
			if(stdv() > threshold)
			{
				robotProperties[AVOIDING].leftSpeed = MOTORSPEED *2;
				robotProperties[AVOIDING].rightSpeed = MOTORSPEED *3;
			}
			else
			{
				state = nothing;

			}
			break;
		case nothing:
			{
				robotProperties[AVOIDING].leftSpeed = 0;
				robotProperties[AVOIDING].rightSpeed = 0;
				sleep(200);
				robotProperties[AVOIDING].active = false;
			}
		}
	}
}

task followLine()
{
	bool lostLine = true;
	bool black = true;
	bool white = true;
	int intensity = 0;
	while(true)
	{

		if(lostLine)
		{

			while(stdv() < threshold)
			{
				robotProperties[FOLLOWING].leftSpeed = MOTORSPEED;
				robotProperties[FOLLOWING].rightSpeed = -MOTORSPEED;
				robotProperties[FOLLOWING].active = true;
				if(stdv() > threshold)
				{
					clearTimer(T1);
					lostLine = false;
				}
			}
		}
		else
		{



			if(stdv() < threshold)
			{
				if(white)
				{
					white = false;
					intensity = 0;
				}
				if (intensity < 50)
				{
					robotProperties[FOLLOWING].leftSpeed  = MOTORSPEED + 10 + 0.005 * intensity;
					robotProperties[FOLLOWING].rightSpeed = MOTORSPEED;
				}
				else if (intensity < 100)
				{
					robotProperties[FOLLOWING].leftSpeed  = MOTORSPEED + 10 + 0.01 * intensity;
					robotProperties[FOLLOWING].rightSpeed = MOTORSPEED;
				}
				else
				{
					robotProperties[FOLLOWING].leftSpeed  = MOTORSPEED + 8;
					robotProperties[FOLLOWING].rightSpeed = - MOTORSPEED;
				}
				robotProperties[FOLLOWING].active = true;
				black = true;
				intensity+=5;

				clearTimer(T1);
			}
			else
			{
				if(black)
				{
					black = false;
					intensity = 0;
				}
				if (intensity < 50)
				{
					robotProperties[FOLLOWING].leftSpeed  = MOTORSPEED;
					robotProperties[FOLLOWING].rightSpeed = MOTORSPEED + 10 + 0.005 * intensity;
				}
				else if (intensity < 100)
				{
					robotProperties[FOLLOWING].leftSpeed  = MOTORSPEED;
					robotProperties[FOLLOWING].rightSpeed = MOTORSPEED + 10 + 0.01 * intensity;
				}
				else
				{
					robotProperties[FOLLOWING].leftSpeed  = -MOTORSPEED ;
					robotProperties[FOLLOWING].rightSpeed = MOTORSPEED + 8;
				}

				white = true;
				intensity+=5;
			}
			if(time1[T1] > LOSTTIME)
			{
				robotProperties[FOLLOWING].active = false;
				lostLine = true;
			}
		}
	}
}

//task observe()
//{
//    struct points {
//	int x;
//	int y;
//	int theta;
//  };
//    enum states {
//	mapping,
//	analising,
//	COUNT,
//    };
//    int prevLeftMotor = 0;
//    int prevRightMotor = 0;
//    enum states state = mapping;
//    poinst map[10000];
//    unsigned int mapCounter = 0;
//    while(1)
//    {
//	switch(state)
//	{
//	case mapping:
//	    int leftEncoder = getMotorEncoder(leftMotor);
//	    int rightEncoder = getMotorEncoder(rightMotor);
//	    int deltaL = leftEncoder - prevLeftMotor;
//	    int deltaR = rightEncoder - prevRightMotor;
//	    int theta = deg;
//	    map[mapCounter].x = deltaL;
//	    map[mapCounter].y = deltaR;
//	    map[mapCounter].theta = deg;
//	    mapCounter++;
//	    prevLeftMotor = leftEncoder;
//	    prevRightMotor = rightEncoder;
//	    break;
//	case analising:
//	    int distance[1000];
//	    for(int x = 0;x<mapCounter; x++)
//	    {
//		if(map[x].theta < map[x+1].theta * 1.05)
//		{
//		    distance[x] = sqrt(pow(map[x].x,2) + pow(map[x].y,2));
//		}
//	    }
//	    break;
//	}
//  }
//}

task setMotors()
{
	while(true)
	{
		setMotorSpeed(leftMotor, leftSpeed);
		setMotorSpeed(rightMotor, rightSpeed);
	}
}

char* getState()
{
	if(robotProperties[AVOIDING].active)
		return "Avoiding";
	else if(robotProperties[FOLLOWING].active)
		return "Following";
	else if(robotProperties[FINDING].active)
		return "Fidning";
	return "WTF";
}

task main()
{
	robotProperties[AVOIDING].active = false;
	robotProperties[FOLLOWING].active = false;
	robotProperties[FINDING].active = true;
	startTask(readSensors);

	resetGyro(gyro);
	startTask(avoid);

	startTask(followLine);
	startTask(findLine);
	startTask(setMotors);

	while(1)
	{

		if(robotProperties[AVOIDING].active)
		{
			leftSpeed = robotProperties[AVOIDING].leftSpeed;
			rightSpeed = robotProperties[AVOIDING].rightSpeed;
		}
		else if(robotProperties[FOLLOWING].active)
		{
			leftSpeed = robotProperties[FOLLOWING].leftSpeed;
			rightSpeed = robotProperties[FOLLOWING].rightSpeed;
		}
		else if(robotProperties[FINDING].active)
		{
			leftSpeed = robotProperties[FINDING].leftSpeed;
			rightSpeed = robotProperties[FINDING].rightSpeed;
		}

		displayTextLine(1, "%s", getState());
		displayTextLine(2, "Light %d",light);
		displayTextLine(3, "Ult %d %d", distL, distR);
		displayTextLine(4, "thresh %d",threshold);
	}
}
